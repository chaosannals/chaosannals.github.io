# 关于 Git Cmake 和 c++

早年的 C++ 项目是一坨答辩，其主要的原因是那个时代软件工程不够成熟，项目管理很混乱。编译构造工具都是散乱无标准的。如果现在去使用有些年头的 C++ 开源库，就会发现每个库都有自己的一种或者多种引入方式。在加之 IDE 的引入第三方库的方式，就会把大量的精力用在构造脚本上。谷歌的 devtools ninja gn 一堆自制的构造工具，常规的 make autoconfig 五花八门的脚本。

所以早年的开发者在能拿到源码的时候，依赖管理保存的并非源码，而是编译好的对应 IDE 的二进制文件（.lib .dll）这些进入到版本库，然后通过配置 IDE 各自的方式引入二进制库（Visual Studio 通过设置 库目录 导入目录 这些来引入）。二进制就限制了跨平台，当然可以每个版本都编译一份，事实上也是如此，你可以在大部分库的官网看到二进制文件的下载。

随后有了版本管理 git 之后，就会发现有大量的 c++ 库采用 git 的 submodule 来管理依赖，毕竟 git 切换版本容易，而且是源码级别的，可以根据需要切换编译的目标。不过也导致了一些问题，就是无法使用镜像，尤其是在高墙下，git submodule 几乎写死了链接（也可以改 .gitsubmodule 但是这样就会导致和很多工具不契合，比如 CMAKE）

目前大部分的 c++ 都在转成使用 CMake 的 FetchContent 去发布和依赖。这样可以避免 git submodule 的多层问题，而且 链接 也可以通过 set CACHE STRING 的方式允许使用镜像。在所有库都支持 FetchContent 前的过渡期间 cmake 也可以使用 ExternalProject 来执行各种定制命令的库的脚本并加入过程，虽然编写会很繁琐。

vcpkg 这个是建立在 cmake 基础上的，并非必要，不过和 visual studio 集成度很高。
