# 关于代码的一些总结

## 数据同步与幂等

一般需要有个版本依据。数据最后修改时间。类似各个数据库都有内部的数据版本号用来做事务的判定。

这个依据应该是单向递增且修改时也是由最后递增的。这就让我们很容易的联想到了时间。

此时正向排序（由小到大）获取数据，每次处理一批就要留下最后的凭证。这样程序如果出现 BUG 后修复就可以依据这个凭证 继续，而不用从头开始。

这个依据是重点，选择上很关键，也和精度相关。比如用修改时间就精度不够，因为不管是到了 秒 还是 毫秒，都可能出现重复的依据。此时，就可能因为这个精度而漏掉。所以需要维持一个单调递增的版本号，此版本号虽然也源于时间信息，但做了绝不重复的处理。

## 关于可空与非空

空值错误一直是个常见问题，主要源于语言开发者早年对这个状态的理解模糊。
一般都是采取放开策略，即大部分类型都允许空。
在可空和非空的语法限制上，不少语言都是模糊的，或者早期模糊，后来补上的。
这种做法使得基本上每个字段都要进行动态判断，而这个判断也不是必须的，类型系统并不强制。
因为这样的语法下，导致空值错误横行。
空值很常见，几乎你遇到的大半问题都是空值造成。
解决的办法也很简单，无非就是补上默认数据，或者跳过数据。
后来的语言加入了强制非空的语法特新来消除这个问题。

```csharp
class T {
    // 如果没有这个 required ，当作为参数的合并结构时，这个 Field 是不能确保非空的。
    // 此时必须把 Field 弄到函数的参数里面才能确保其必填，但是也可能被认为写入 null。
    // 比较严谨的老做法是，写一堆 工厂函数 提供不同的初始化方式，标准库也是这么做的。
    public required string Field {get; set;}
}
```

```go
// go 也有同样的问题，而且更没有 required 关键字，同 C# 。
// 只有 结构体初始化块，没有 构造函数，用 工厂函数 替代构造函数。（反面向对象的设计，面向对象确实问题颇多）。
// 这种语法设计，直接就在语言层面上默认是这种方式。
type T struct {
    Field string
}
```

···dart
// Dart 看着像是要致力解决这个问题，所以其语法看着有些古怪。
// 但是却做得比其他语言要好些。
class T {
  final String field;
  const T({required this.field});
}
```

```rust
// rust 比较严格，所有类型都是值，且如果不显示使用 Default 就没有默认值，导致所有值必填。
// Option 也只是让类型变成 Some 和 None 多出来一种状态的一种包装类型。（一开始你会觉得很繁琐）
pub struct T{
  pub field: Option<String>;
}

pub struct T{
  pub field: String;
}

```

## 历史遗留问题

1. 日期格式

```
常规：2024-10-10 01:02:03
RFC3339: 2024-10-10T01:02:03Z08:00
```

常规的格式丢失了时区信息，这种如果存储数据库必然造成数据在多时区情况下混乱。
然后不同语言和框架采取的不同策略又造成了二次混乱。
有的语言把常规认定为0时区的缺省，而有的认为是本地时区的缺省。
造成了在框架层面上需要解决此类问题。但是大部分框架又都没有解决此类问题。
